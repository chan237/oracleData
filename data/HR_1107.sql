create TABLE emp03
as
select * from employees;

--모든 사원의 부서번호를 30번으로 수정
SELECT * FROM emp03;
update emp03 set department_id = 30;
ROLLBACK;

--모든 사원의 급여를 10%인상
update emp03 set salary = salary*1.1;

--입사일을 오늘로 수정
update emp03 set hire_date = sysdate;

--부서번호가 10번인 사원의 부서번호를 30번으로 수정
update emp03 set department_id = 30 where department_id = 10;

--급여가 3000이상인 사원만 급여를 10%인상
update emp03 set salary = salary*1.1 where salary >=3000;

--2007년에 입사한 사원의 입사일이 오늘로 수정
update emp03 set hire_date = sysdate where substr(hire_date,1,2)='07';

--이름이 susan의 부서번호는 20번으로, 직급은 FI_MGR
update emp03 set department_id = 20, job_id = FI_MGR where first_name = 'Susan';

--Last_name이 Russell인 사원의 급여를 17000로 커미션 빙ㄹ이 0.45로 인상
update emp03 set salary = 17000, commission_pct = 0.45 where last_name = 'Russell';

--30번 부서를 삭제
delete from emp03 where department_id = 30;
SELECT * FROM emp03 where department_id = 30;


-- 부서별에 따라 급여 인상
select employee_id, first_name, department_id, salary,
        decode(department_id, 20, salary*1.05, 30, salary*1.1, 
        40, salary*1.15, 60, salary*1.2) as salary2
from employees;


-- 부서별에 따라 급여를 인상하도록 하자. (조인 : INNER JOIN, OUTER JOIN, SELF JOIN, CROSS JOIN)
-- (직원번호, 직원명, 직급, 급여)
-- 부서ID에 따라서 'MARKETING'인 직원은 5%, 'PURCHASING'인 사원은 10%, 
-- 'HUMAN RESOURCES'인 사원은 15%, 'IT'인 사원은 20% 인상한다.
SELECT * FROM DEPARTMENTS;
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID FROM EMPLOYEES;
SELECT * FROM EMPLOYEES INNER JOIN DEPARTMENTS ON EMPLOYEES.DEPARTMENT_ID = D.DEPARTMENT_ID;

SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY, EMPLOYEES.DEPARTMENT_ID, DEPARTMENT_NAME,
    CASE
    WHEN UPPER(DEPARTMENTS.DEPARTMENT_NAME) = UPPER('MARKETING') THEN SALARY * 1.05
    WHEN UPPER(DEPARTMENTS.DEPARTMENT_NAME) = UPPER('PURCHASING') THEN SALARY * 1.10
    WHEN UPPER(DEPARTMENTS.DEPARTMENT_NAME) = UPPER('HUMAN RESOURCES') THEN SALARY * 1.15
    WHEN UPPER(DEPARTMENTS.DEPARTMENT_NAME) = UPPER('IT') THEN SALARY * 1.20
    END NEWSALARY
FROM EMPLOYEES INNER JOIN DEPARTMENTS ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID
WHERE UPPER(DEPARTMENTS.DEPARTMENT_NAME) IN (UPPER('MARKETING'),UPPER('PURCHASING'),UPPER('HUMAN RESOURCES'),UPPER('IT'))
ORDER BY NEWSALARY DESC;

--테이블 생성
create table My_customer(
    code varchar2(7),
    name varchar2(10) not null,
    gender char(1) not null,
    birthday varchar2(8) not null,
    phone varchar2(16)
);
--제약조건 추가
ALTER TABLE My_customer ADD CONSTRAINT My_customer_code_PK PRIMARY KEY(code);
ALTER TABLE My_customer ADD CONSTRAINT My_customer_gender_CK CHECK(gender in('m','w'));
ALTER TABLE My_customer ADD CONSTRAINT My_customer_phone_UK UNIQUE(phone);
SELECT * FROM user_constraints where table_name = upper('My_customer');
SELECT * FROM user_tables where table_name = upper('My_customer');
SELECT * FROM user_cons_columns where table_name = upper('My_customer');
ALTER TABLE My_customer DROP CONSTRAINT My_customer_phone_UK;

-- 병합
CREATE TABLE MYCUSTOMER(
    code VARCHAR2(7),
    name VARCHAR2(10) CONSTRAINT MYCUSTOMER_NAME_NN NOT NULL,
    gender CHAR(1) NOT NULL,
    birth VARCHAR2(8)NOT NULL,
    phone VARCHAR2(16)
);
CREATE TABLE CUSTOMER(
    code VARCHAR2(7),
    name VARCHAR2(10) CONSTRAINT CUSTOMER_NAME_NN NOT NULL,
    gender CHAR(1) NOT NULL,
    EMAIL VARCHAR2(8)NOT NULL,
    phone VARCHAR2(16)
);

ALTER TABLE MYCUSTOMER ADD CONSTRAINT MYCUSTOMER_code_PK PRIMARY KEY(code);
ALTER TABLE MYCUSTOMER ADD CONSTRAINT MYCUSTOMER_gender_CK CHECK(gender IN('M','W'));
ALTER TABLE MYCUSTOMER ADD CONSTRAINT MYCUSTOMER_PHONE_UK UNIQUE(PHONE);
DESC MYCUSTOMER;

INSERT INTO MYCUSTOMER VALUES ('2017108','박승대','M','19711430','010-2580-9919');
INSERT INTO MYCUSTOMER VALUES ('2019302','전미래','W','19740812','010-8864-0232');
SELECT * FROM MYCUSTOMER;
SELECT * FROM CUSTOMER;
DESC CUSTOMER;

-- 제약조건 검색기능(반드시 알아둘것)
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'CUSTOMER';
SELECT * FROM USER_TABLES;
SELECT * FROM user_cons_columns WHERE TABLE_NAME = 'CUSTOMER';
ALTER TABLE CUSTOMER DROP CONSTRAINT CUSTOMER_EMAIL_UK;
ALTER TABLE CUSTOMER DROP CONSTRAINT CUSTOMER_GENDER_CK;


-- MERGE  MYCUSTOMER - > CUSTOMER 병합을진행하는데 없으면 INSERT, 있으면 UPDATE
MERGE INTO CUSTOMER C
    USING MYCUSTOMER M
    ON (C.CODE = M.CODE)
    WHEN MATCHED THEN
        UPDATE SET C.NAME = M.NAME, C.GENDER = M.GENDER, C.BIRTH = M.BIRTH, C.PONE = M.PHONE 
    WHEN NOT MATCHED THEN
        INSERT (C.CODE,C.NAME,C.GENDER,C.BIRTH, C.PONE) values(M.CODE,M.NAME,M.GENDER,M.BIRTH, M.PHONE);

SELECT * FROM CUSTOMER;
SELECT * FROM MYCUSTOMER;
UPDATE MYCUSTOMER SET NAME = '박승우' WHERE CODE = '2017108';

DROP TABLE EMP03;
DROP TABLE CUSTOMER;

CREATE TABLE DEP01(
    DEP_NO NUMBER(10),
    DEP_NAME VARCHAR(10),
    DEP_ADRR VARCHAR(10)
);
ALTER TABLE DEP01 ADD CONSTRAINT DEP01_DEP_NO PRIMARY KEY(DEP_NO);
CREATE TABLE EMP01(
    NO NUMBER(10),
    NAME VARCHAR(10),
    JOB VARCHAR(10),
    SALARY NUMBER(10),
    DEP_NO NUMBER(10)
);
ALTER TABLE EMP01 ADD CONSTRAINT EMP01_NO PRIMARY KEY(NO);
ALTER TABLE EMP01 ADD CONSTRAINT EMP01_DEP_NO_FK FOREIGN KEY(DEP_NO) 
REFERENCES DEP01(DEP_NO);
SELECT * FROM user_constraints where table_name = 'EMP01';
INSERT INTO EMP01 VALUES(7566,'JONES','MANAGER',50,NULL);
SELECT * FROM EMP01;


--문제풀이

--테이블 생성 DEPT01
CREATE TABLE DEPT01(
    DEPTNO NUMBER(10),
    DNAME VARCHAR(10),
    LOC VARCHAR(10)
);
--무결성 제약조건
ALTER TABLE DEPT01 ADD CONSTRAINT DEPT01_DEPTNO PRIMARY KEY(DEPTNO);

--테이블 생성 EMP03
CREATE TABLE EMP03(
    EMPNO NUMBER(10),
    ENAME VARCHAR(10),
    JOB VARCHAR(10),
    DEPTNO NUMBER(10)
);
--무결성 제약조건
ALTER TABLE EMP03 ADD CONSTRAINT EMP03_NO PRIMARY KEY(EMPNO);
ALTER TABLE EMP03 ADD CONSTRAINT EMP03_DEPTNO_FK FOREIGN KEY(DEPTNO) REFERENCES DEPT01(DEPTNO); 

--값 입력 DEPT01
INSERT INTO DEPT01 VALUES(10,'ACCOUNTING','NEW YORK');
INSERT INTO DEPT01 VALUES(20,'RESEARCH','DALLAS');
INSERT INTO DEPT01 VALUES(30,'SALES','CHICAGO');
INSERT INTO DEPT01 VALUES(40,'OPERATION','BOSTON');
--값 입력 EMP03
INSERT INTO EMP03 VALUES(7499,'ALLEN','SALESMAN',30);
INSERT INTO EMP03 VALUES(7566,'JONES','MANAGER',50); --에러(50값 없음)
INSERT INTO EMP03 VALUES(7566,'JONES','MANAGER',40); --값 바꾸면 무결성 통과

DELETE FROM DEPT01 WHERE DEPTNO = 40; --EMP03에 자식레코드가 있어서 에러
DELETE FROM EMP03 WHERE DEPTNO = 40; --먼저 삭제해주면 위에도 작동가능 

--CASCADE 를 사용한 오류방지(부모꺼 지우면 자식건 자동으로 사라짐)
ALTER TABLE EMP03 DROP CONSTRAINT EMP03_DEPTNO_FK;
ALTER TABLE EMP03 ADD CONSTRAINT EMP03_DEPTNO_FK FOREIGN KEY(DEPTNO) REFERENCES DEPT01(DEPTNO)ON DELETE CASCADE; 

DELETE FROM DEPT01 WHERE DEPTNO = 40; --CASCADE를 써서 오류안뜸(자식것도 삭제해버림)

SELECT * FROM EMP03;
SELECT * FROM DEPT01;

DROP TABLE DEPT01;
DROP TABLE EMP03;